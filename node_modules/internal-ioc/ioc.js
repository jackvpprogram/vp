(function (exports) {
    function InversionOfControl (modules, globals, options) {
        this.modules = modules || {}
        var injector = this

        options = options || {}

        var symbolSeparator = options.symbolSeparator || "/"

        function getSymbol(thing) {
            switch (typeof thing) {
                case "object":
                    return thing.symbol
                    break
                default:
                    return thing
            }
        }

        function getMatchingModules(regex) {
            var result = {}
            !Object.keys(injector.modules)
                .filter(function (key) {
                    return regex.exec(key)
                })
                .forEach(function (key) {
                    var name = key.split(symbolSeparator).pop()
                    result[name] = injector.modules[key]
                })

            return result
        }

        this.inject = function (fn) {
            if (!fn._depends) {
                return fn
            }

            var deps = this.getDependencies(fn._depends)

            if (deps.symbol && this.modules[getSymbol(deps.symbol)]) {
                return this.modules[getSymbol(deps.symbol)]
            }

            if (!(deps.modules || []).length) {
                if (deps.symbol) {
                    this.modules[getSymbol(deps.symbol)] = fn
                }

                return fn
            }

            var resolvedFn = function () {
                var args = Array.prototype.slice.call(arguments)
                var invokeArgs = []
                var mods = null

                if (resolvedFn._modules && resolvedFn._modules.missing.length == 0) {
                    mods = resolvedFn._modules
                } else {
                    mods = deps.modules.reduce(function (mods, module, index) {

                        if (typeof module == "object" && module instanceof RegExp) {
                            mods.resolved[index] = getMatchingModules(module)
                            return mods
                        }

                        var symbol = getSymbol(module)

                        if (symbol && injector.modules[symbol]) {
                            mods.resolved[index] = injector.modules[symbol]
                        } else if (symbol.indexOf(symbolSeparator) < 0 && globals[symbol]) {
                            mods.resolved[index] = globals[symbol]
                        } else if (module.tryGlobal && globals && globals[symbol]) {
                            mods.resolved[index] = globals[symbol]
                        } else {
                            mods.missing.push(module)
                        }

                        return mods

                    }, { resolved : {}, missing : [] })
                }

                resolvedFn._modules = mods

                deps.modules.forEach(function (mod, index) {
                    if (mods.resolved[index]) {
                        invokeArgs.push(mods.resolved[index])
                    } else if (deps.modules[index] && deps.modules[index].nullIfMissing) {
                        invokeArgs.push(null)
                    } else {
                        invokeArgs.push(args.shift())
                    }
                })

                return fn.apply(this, invokeArgs.concat(args))
            }

            !Object.keys(fn).forEach(function (key) {
                resolvedFn[key] = fn[key]
            })

            resolvedFn._depends = deps

            if (deps.symbol) {
                resolvedFn._symbol = deps.symbol
                this.modules[deps.symbol] = resolvedFn
            }

            return resolvedFn
        }

        this.injectWithModules = function (modules, fn) {
            var resolvedFn = function () {
                var args = Array.prototype.slice.apply(arguments)

                var invokeArgs = []

                modules.forEach(function (module) {
                    if (typeof module == "object" && module instanceof RegExp) {
                        invokeArgs.push(getMatchingModules(module))
                        return
                    }

                    var symbol = getSymbol(module)

                    if (symbol && injector.modules[symbol]) {
                        invokeArgs.push(injector.modules[symbol])
                    } else if (module.nullIfMissing) {
                        invokeArgs.push(null)
                    } else {
                        invokeArgs.push(args.shift())
                    }
                })

                return fn.apply(this, invokeArgs.concat(args))
            }

            !Object.keys(fn).forEach(function (key) {
                resolvedFn[key] = fn[key]
            })

            return resolvedFn
        }

        this.call = function (modules, fn) {
            var invokeArgs = []
            var args = Array.prototype.slice.call(arguments, 2)

            modules.forEach(function (module) {
                if (typeof module == "object" && module instanceof RegExp) {
                    invokeArgs.push(getMatchingModules(module))
                    return
                }

                var symbol = getSymbol(module)

                if (symbol && injector.modules[symbol]) {
                    invokeArgs.push(injector.modules[symbol])
                } else if (module.nullIfMissing) {
                    invokeArgs.push(null)
                } else {
                    invokeArgs.push(args.shift())
                }
            })

            return fn.apply(this, invokeArgs.concat(args))
        }

        this.run = function (module) {
            var args = Array.prototype.slice.call(arguments, 1)

            var symbol = getSymbol(module)

            if (!symbol) {
                throw new Error("Unable to resolve symbol:" + module)
            }

            var fn = injector.modules[symbol]

            if (!fn) {
                throw new Error("Unable to find module: " + symbol)
            }

            if (typeof fn != "function") {
                return fn
            }

            return fn.apply(this, args)
        }

        this.injectAll = function (object, options) {
            var injectedModules = {}
            for (var key in object) {
                if (object.hasOwnProperty(key) && object[key]._depends) {
                    injectedModules[key] = this.inject(object[key])
                }
            }

            return injectedModules
        }

        this.define = function (symbol, value) {
            this.modules[getSymbol(symbol)] = value
        }

        this.getDependencies = function (depends) {
            var deps = {
                modules : [],
                symbol : null
            }

            if (depends.modules || depends.symbol) {
                return depends
            } else if (typeof depends.slice == "function") {
                deps.modules = depends.slice()
            }

            return deps
        }

        this.getSymbol = getSymbol
    }

    exports.IoC = exports.InversionOfControl = InversionOfControl
    exports.ioc = new InversionOfControl({}, typeof window == "object" ? window : typeof globals == "object" ?  globals : {})
    exports.ioc.define("3r/ioc", exports.ioc)
    exports.ioc.define("3r/InversionOfControl", InversionOfControl)

    if (typeof window == "object" && window == exports) {
        exports.ioc.define("window", window)
    }
})(typeof exports == "object" ? exports : this)
