//Configure a topWindow variable to point
//to the top window only if it is accessible
//given CORS requirements

var topLocation
var topWindow;

if (typeof top == "object" && typeof window == "object") {
    topLocation = top.document
    topWindow = window.top;

    if (!topWindow || !topWindow.navigator) topWindow = window
} else if(typeof window == "object") {
    topWindow = window
}

if (topWindow && !topWindow.appCode && topWindow.schemeId) {
    topWindow.appCode = topWindow.schemeId
}

var storage

if (typeof window == "object") {
    var Radical = window.Radical || {}
    if (!topWindow) topWindow = window
    if (!topWindow || !topWindow.navigator) topWindow = window

    if (window.storage) {
        storage = window.storage.default
    }

    if (!storage && typeof localStorage == "object") {
        storage
    }
}


function deviceFactory ($, _, Q, storage, getApiAddress, window, schemeSettings, context) {
    context = context || {}
    var schemeId = null

    if (context.schemeId) {
        schemeId = context.schemeId
    } else if (topWindow && topWindow.schemeId) {
        schemeId = topWindow.schemeId
    }

    if (!schemeSettings) {
        schemeSettings = { globals: {}}
    }

    if (typeof getParameterByName != "function") {
        var getParameterByName = function () {
        }
    }

    if (typeof appName == "undefined") {
        var appName = schemeId
    }

    if (typeof window != "undefined" && window.addEventListener) {
        window.addEventListener('message', function (event) {
            if (event.data.unlock) {
                that.unlock(event.data.unlock.code, event.data.unlock.packet)
            }
        })
    }

    function getLocations() {
        return api('getLocations', {
            schemeId: schemeId,
            uid: Device.thrid
        }).then(function(results) {
            Device.locations = results.results.locations
            Device.locationLookup = _.indexBy(results.results.locations, 'id')
        })
    }


    //Wrap local storage to trap for private mode
    function setItem(key, value) {
        try {
            localStorage.setItem(key, value)
        } catch (e) {

        }
    }

    function getItem(key, value) {
        try {
            return localStorage.getItem(key) || value
        } catch (e) {
            return value
        }
    }

    storage = storage || localStorage

    function radicalNoop() {
        console.log("No Operation")
    }

    var empty = {}
    var groups = {}

    function invokeParams(array, refThis, b) {
        if (!array || array.$processing) {
            return
        }

        array.$processing = true

        var i, l
        var parameters = empty
        if (b) {
            parameters = Array.prototype.slice.call(arguments, 2)
        }

        for (i = 0, l = array.length; i < l; i++) {
            try {
                array[i].apply(refThis, parameters)
            }
            catch (e) {
                console.error(e.stack)
            }
        }
        array.$processing = false
    }

    function invoke(array, refThis) {
        if (!array) {
            return;
        }

        for (var i = array.length - 1; i >= 0; i--) {
            array[i].apply(refThis);
        }
    }

    function guid() {
        return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0, v = c == 'x'
                ? r
                : (r & 0x3 | 0x8)
            return v.toString(16).toUpperCase()
        })
    }

    var globals = typeof Radical != "undefined" && Radical.radicalGlobals !== false
    if (globals) {
        console.log("Configure globals")

        if (typeof topWindow == "object") {
            window.console = topWindow.console
            topWindow.setId = topWindow.setId || radicalNoop
            window.navigator.geolocation = topWindow.navigator.geolocation
            topWindow.badgeCount = topWindow.badgeCount || radicalNoop
        }

        window.$$services = {
            gtp: 3001,
            api: 3000,
            gtps: 3040,
            apis: 3009
        }
    }
    var sessionId = guid()

    var isCDNLocal = typeof window == "object" && window.cdnPath && (_.startsWith(window.location.href,
            window.cdnPath) || _.startsWith(window.location.href, window.cdnOverride))

    var apiAddress = null

    var events = {}

    function trigger(name, parameters) {
        try {
            $(that).triggerHandler(name, parameters);
            var list = events[name] || []
            var params = Array.prototype.slice.call(arguments, 1)
            params.unshift(that)
            params.unshift(list)
            invokeParams.apply(that, params)
        }
        catch (e) {
            console.error(e.stack)
        }
    }

    var statusList = []
    var infoList = []
    var idList = []
    var hasStatus = false
    var hasInfo = false
    var hasId = false

    function resolveMessage(message) {
        if (_.isObject(message)) {
            return message
        }
        return (that.info.messages.filter(function (m) {
            return m.systemId == message
        }) || [null])[0]
    }

    function pushIfNeeded(array, fn) {
        if (array.indexOf(fn) == -1) {
            array.push(fn)
        }
    }//

    var lastProcessedBy = {}

    function makeProcessedByChangeDetector(name) {
        return function (xhr) {
            if (xhr && typeof xhr.getResponseHeader == "function") {
                var processedBy = (xhr.getResponseHeader("x-processed-by") || xhr.getResponseHeader("x-processed-id"))

                if (!processedBy) {
                    return
                }

                if (!lastProcessedBy[name]) {
                    lastProcessedBy[name] = processedBy
                    return
                }

                if (lastProcessedBy[name] != processedBy) {
                    lastProcessedBy[name] = processedBy
                    if (typeof appStats == "object") {
                        appStats.inc(["web", "processedBy", "change", "sha256:isM59YQn30RYzv2usI+/DX/+YD2GlXACsu6eCxJ3qMU="], 1, { tags : { service : name } })
                    }
                }
            }
        }
    }

    function makeRequestSizeReporter(name) {
        return function (xhr) {
            if (xhr && typeof appStats == "object") {
                if ((this || {}).url) {
                    appStats.hist(["web", "request", "hist", "urlLength", "sha256:I4f7HR2xuRsD83RH/lkBnGiwnJzyRpoqgxU5fQHKGUM="], this.url.length, { tags : { service : name } })
                }

                if ((this || {}).hasContent) {
                    appStats.hist(["web", "request", "hist", "bodySize", "sha256:gu+Xp7ikRjjUazT4gjonws1XblYvWQzlRQKZY1oLGNs="], this.data.length, { tags : { service : name } })
                }

                if (xhr.responseText) {
                    appStats.hist(["web", "response", "hist", "bodySize", "sha256:uyzQ0AhSPeZBOuvNLV0hX61NPkfYkBA/MDopTW+iExQ="], xhr.responseText.length, { tags : { service : name } })
                }
            }
        }
    }

    function makeRequestTimerReporter(name) {
        var timer = null

        if (typeof appStats == "object") {
            timer = appStats.timer()
        }

        return function (xhr) {
            if (timer) {
                timer.mark(["web", "response", "time", "sha256:HGpYMlpHgwNtRsnGqfhGtlzpc63Vzinh0LcL5vPl3tw="], { tags : { service : name } })
            }
        }
    }

    function makeRequestErrorReporter(name) {
        return function (xhr) {
            if (xhr && xhr.status && xhr.status >= 400 && typeof appStats == "object") {
                appStats.inc(["web", "request", "error", "sha256:KfKTmGHHEEJMvVnTI9myF3BHkrA9OqB/P2XMY8tI7DM="], { tags : { status : xhr.status.toString().substr(0,1), service : name } })
            }
        }
    }

    function remove(array, fn) {
        var idx = array.indexOf(fn)
        if (idx != -1) {
            array.splice(idx, 1)
        }
    }

    function api(command, options, verb) {
        _.merge(options, {cacheKill: Date.now()})
        return Q($.ajax({
            url: getApiAddress({
                port: 3030,
                path: 'api/' + command
            }),
            data: options,
            type: verb || 'get',
            dataType: 'json',
            complete: [
                makeProcessedByChangeDetector("api"),
                makeRequestSizeReporter("api"),
                makeRequestTimerReporter("api"),
                makeRequestErrorReporter("api")
            ]
        }))
    }

    var gtpResultList = []

    function processUnlockResults(result) {
        if (shouldRefreshInfo(result)) {
            getInfo()
        }
        trigger('unlock', result.hasOwnProperty('response') ? result : _.extend({}, result, {response: result}))
    }

    function gtp(command, options, verb) {
        var retries = 0
        options = options || {}
        _.merge(options,
            {
                cacheKill: Date.now(),
                schemeId: schemeId
            })
        options.uid = Device.thrid
        command = command.replace(/:([a-zA-Z0-9_]+)/ig, function (match, capture) {
            var value = encodeURIComponent(options[capture])
            delete options[capture]
            return value || ""
        })
        return Q($.ajax({
            url: getApiAddress({
                port: 3040,
                path: command
            }),
            data: options,
            type: verb || 'get',
            timeout: 30000,
            complete: [
                makeProcessedByChangeDetector("gtp"),
                makeRequestSizeReporter("gtp"),
                makeRequestTimerReporter("gtp"),
                makeRequestErrorReporter("gtp")
            ]
        })).then(function (results) {
            if (typeof results == 'string') {
                try {
                    results = JSON.parse(results)
                } catch (e) {

                }
            }
            if (typeof results == 'object')
                trigger('gtp', results)
            return results
        })
    }

    var lastLocation = getItem('lastUrl')
    if (lastLocation && lastLocation != window.location.host + window.location.pathname) {
        setTimeout(function () {
            that.forget()
        }.bind(this), 10)
    }

    if (typeof window == "object") {
        setItem('lastUrl', window.location.host + window.location.pathname)
    }

    var device

    if (typeof topWindow == "object") {
        device = topWindow.deviceId
    }

    if (!device && getParameterByName('deviceId')) {
        device = getParameterByName('deviceId')
    }

    if (!device && getItem('device-id')) {
        device = getItem('device-id')
    }

    if (!device) {
        device = guid()
    }

    if (typeof window == "object") {
        if (!window.skipDevicePrefix && device.indexOf('| |') == -1) {
            device = schemeId + "| |" + (getParameterByName('application') ? getParameterByName('application') + ":" : "") + device
        }
    }

    try {
        if (globals) {
            window.deviceId = device
        }
        setItem('device-id', device)

    }
    catch (e) {

    }

    function getHiddenProp() {
        var prefixes = ['webkit', 'moz', 'ms', 'o'];

        if (typeof document == "undefined") {
            return null
        }

        // if 'hidden' is natively supported just return it
        if ('hidden' in document) return 'hidden';

        // otherwise loop over all the known prefixes until we find one
        for (var i = 0; i < prefixes.length; i++) {
            if ((prefixes[i] + 'Hidden') in document) {
                return prefixes[i] + 'Hidden';
            }
        }

        // otherwise it's not supported
        return null;
    }

    function isHidden() {
        var prop = getHiddenProp()
        if (!prop) return false
        return document[prop]
    }

    var visProp = getHiddenProp();
    if (visProp) {
        var evtname = visProp.replace(/[H|h]idden/, '') + 'visibilitychange';
        document.addEventListener(evtname, function visibilityChange() {
            trigger('visibility', isHidden())
            if (isHidden()) {
                trigger('hidden')
            } else {
                trigger('shown')
            }
        });
    }

    function register() {
        /****************************************************************************
         * window.noRegisterDev is defined in MP - schemeSettings.globals.noRegisterDev
         * It's needed when the webframework is embedded in client's app,
         * client will do the registerDev and pass the guid to webframework
         ****************************************************************************/
        if (window.noRegisterDev == "yes") {
            var guid = getParameterByName("guid")
            processWithUid(guid)
            console.log("00 mark: skip register() and use the guid passed from URL by client: " + guid)
            return false
        }
        else {
            console.log("00 mark: window.noRegisterDev is not defined")
        }

        function processWithUid(uid) {
            window.thrid = uid
            if ((topWindow || window).setId) {
                (topWindow || window).setId(uid)
            }
            that.thrid = uid
            getLocations()
            storage.setItem('thrid', that.thrid)
            invokeParams(idList, that, uid)
            setInterval(function () {
                if (that.paused) {
                    return
                }
                getInfo()
            }, 1000 * 60)
            return getInfo()
        }

        return api('registerDev', {
                mode: 'start',
                duid: device,
                uid: that.thrid,
                app: appName,
                referrer: getParameterByName('referrer'),
                schemeId: schemeId
            })
            .then(function (data) {
                if (data.requestStatus.failureCode) {
                    if([111,400].indexOf(data.requestStatus.failureCode) > -1 && data.requestStatus.failureMessage.indexOf('Invalid UID') > -1) {
                        return that.forget()
                    }
                    setTimeout(register, 1000)
                    return
                }
                    console.log("Is Registered")

                var infoPromise = processWithUid(data.results.uid)
                trigger('registered', data.results)
                return infoPromise
            }).fail(function (e) {
                console.log(e, e.stack)
                if (window.Offline && window.Offline.state == 'down') {
                    function registerOnUp() {
                        Offline.off('up', registerOnUp)
                    }

                    Offline.on('up', registerOnUp)
                } else {
                    setTimeout(register, 1000)
                }
            })
    }

    var lastMessageDate

    if (typeof Radical != "undefined" && Radical.enableSocket) {
        var socketUrl = (window.apiAddress ? window.apiAddress : window.location.protocol + "//" + window.location.hostname) + "/api";
        var socket = io.connect(socketUrl)
        socket.on('connect', function () {
            socket.emit('register', {duid: device})
        })
        socket.on('status', function (state) {
            console.log("received status")
            that.status = state
            hasStatus = true
            trigger('status', state)
            invokeParams(statusList, that, state)
            getInfo()
        })
        socket.on('handshake', function (info) {
            trigger('handshake', info)
            //console.log("Handshake", info)
        })
    }

    if (typeof navigator == "undefined") {
        var isiPad = false
    } else {
        var isiPad = navigator.userAgent.match(/iPad/i) != null && top != window
    }

    var currentGetInfo = Q($.when())
    var queuedGetInfo
    var failedUserInfo = 0
    var lookup = {}

    function oldgetInfo() {

        return currentGetInfo = api('getInfo', {
            uid: that.thrid,
            schemeId: schemeId,
            nolocations: true
        })
            .then(function (info) {
                that.info = info.results
                lookup = {}
                that.info.messages.forEach(function (m) {
                    lookup[m.ATTRIBUTES.id] = m
                    m.categories = {}
                    _.forEach(m.category.toLowerCase().split(' '), function (cat) {
                        m.categories[cat] = true
                    })
                    that.received(m)
                })
                that.permanentId =
                    info.results && info.results.user && info.results.user.data
                        ? info.results.user.data.permanentId
                        : window.thrid
                hasInfo = !!that.info
                updateInfo()
                try {
                    storage.setItem('getinfo', JSON.stringify(that.info))
                }
                catch (e) {
                    console.error("error setting getinfo storage", e.stack)
                }
                return info
            })

    }

    var campaigns = {} //JSON.parse(storage.getItem('campaigns') || '{}')
    var messages = {}//JSON.parse(storage.getItem('messages') || '{}')
    var progressions = {}
    var developer = getParameterByName('developer')
    var tester = getParameterByName('tester')
    var app = getParameterByName('app')
    var appAddress = getParameterByName('useapi')
    var radicalRealmsSupport = getParameterByName('radicalrealms')
    var lastCampaignTime = 0


    function evaluateInContext(expression, suppliedData) {
        expression = expression.replace(/&nbsp;/ig, " ").replace(/`|‘|’/g, "'")
        return function () {
            try {
                var user = that.info.user
                var uid = Device.thrid
                var messages = that.info.messages
                var profile = ((that.info.user.data.variables || {}).public || {}).profile || {}
                var extra = suppliedData
                return eval(expression)
            } catch (e) {
                console.error("Error with expression", expression, e)
            }
        }()
    }

    function getInfo() {
        "use strict"
        var results
        if (Date.now() - lastCampaignTime > 1000 * 60 * 10) {
            campaigns = {}
            lastCampaignTime = Date.now()
        }

        if (queuedGetInfo) {
            return queuedGetInfo
        }

        if (currentGetInfo.isPending()) {
            if (!queuedGetInfo) {
                queuedGetInfo = currentGetInfo.finally(function () {
                    if (queuedGetInfo) {
                        queuedGetInfo = undefined
                        return getInfo()
                    }
                    return currentGetInfo
                })
            }
            return queuedGetInfo
        }

        var currentInfo = currentGetInfo
        return currentInfo.then(function () {
            console.log('getInfo')
            return currentGetInfo = api('get', {
                uid: that.thrid,
                schemeId: schemeId,
                service: radicalRealmsSupport ? 1 : undefined
            }).then(function (info) {
                results = info.results
                var missing = _(results.messages)
                    .uniq('cid')
                    .map(function (m) {
                        return campaigns[m.cid]
                            ? null
                            : m.cid
                    })
                    .filter(function (m) {
                        return m
                    })
                    .value()

                if (missing.length) {
                    return api('getCampaigns',
                        {
                            uid: that.thrid,
                            campaigns: JSON.stringify(missing)
                        })
                        .then(function (response) {
                            _.forEach(response.results, function (r) {
                                campaigns[r.Id] = r
                            })
                            // storage.setItem('campaigns', JSON.stringify(campaigns))

                        })

                }
            }).then(function () {
                var missing = _(campaigns)
                    .map(function (m) {
                        return m
                    })
                    .uniq('messageId')
                    .map(function (m) {
                        return messages[m.messageId]
                            ? null
                            : m.messageId
                    })
                    .filter(function (m) {
                        return m
                    })
                    .value()
                if (missing.length) {
                    return api('getMessages',
                        {
                            uid: that.thrid,
                            messages: JSON.stringify(missing)
                        })
                        .then(function (response) {
                            _.forEach(response.results, function (r) {
                                messages[r.id] = r
                            })
                            try {
                                storage.setItem('messages', JSON.stringify(messages))
                            }
                            catch (e) {

                            }
                        })
                }
            }).then(function () {
                var toProcess = _(results.messages)
                    .filter(function (message) {
                        return campaigns[message.cid].quantities.unlockablesToCount
                    })
                    .map(function (message) {
                        return campaigns[message.cid].quantities.unlockablesToCount.split(',').map(function (code) {
                            return {message: message, code: code.trim()}
                        })
                    })
                    .flatten()
                    .map(function (code) {
                        return gtp('count/:code', {code: code.code})
                            .then(function (result) {
                                return {message: code.message, error: result.count==0 || result.error }
                            })
                    }).value()
                return Promise.all(toProcess).then(function (response) {
                    _(response)
                        .filter(function (code) {
                            return code.error
                        })
                        .forEach(function(code) {
                            code.message.notAvailable = true
                        })
                })
            }).then(function () {
                if (!results.user) {
                    console.log("No User")
                    failedUserInfo = failedUserInfo + 1

                    if (failedUserInfo >= 5) {
                        Device.forget()
                    } else {
                        Q.delay(1000)
                            .then(getInfo)
                    }
                    return
                } else {
                    failedUserInfo = 0
                }
                results.user.progress = results.user.progress || {}
                results.user.progress.progressions = results.user.progress.progressions || {}
                var missing = _.filter(results.user.progress.progressions, function (p) {
                    return p && !progressions[p.id]
                })
                return $.when.apply($, missing.map(function (m) {
                    return gtp('/progress/definition/:id', {
                        id: m.id
                    }).then(function (response) {
                        progressions[m.id] = response
                        return response
                    })
                }))
            }).then(function () {
                that.info = results
                if (results.user) {
                    _.forEach(_.filter(results.user.progress.progressions, function (p) {
                        return p
                    }), function (p) {
                        p.definition = progressions[p.id]
                    })
                }

                that.info.messages = _(results.messages).filter(function (f) {
                    return f && campaigns[f.cid] && messages[campaigns[f.cid].messageId] && !f.notAvailable
                }).map(function (m) {
                    return _.extend({
                        ATTRIBUTES: _.extend({},
                            m,
                            {
                                messageClassName: campaigns[m.cid].className,
                                validFrom: campaigns[m.cid].validFrom,
                                validTo: campaigns[m.cid].validTo
                            })
                    }, messages[campaigns[m.cid].messageId], campaigns[m.cid])
                }).value()
                lookup = {}
                that.info.messages.forEach(function (m) {
                    lookup[m.ATTRIBUTES.id] = m
                    m.categories = {}
                    _.forEach(m.category.toLowerCase().split(' '), function (cat) {
                        m.categories[cat] = true
                    })
                    that.received(m)
                })
                that.info.messages = _(that.info.messages)
                    .filter(function (message) {
                        if (!message) return false
                        if (message.categories['development'] && !developer) return false
                        if (message.categories['testing'] && !tester) return false

                        if ((message.quantities || {}).userDataUnlock && message.quantities.userDataUnlock.expression) {
                            try {
                                return evaluateInContext(message.quantities.userDataUnlock.expression)
                            } catch (e) {
                                console.warn("Exception whilst evaluating expression", e)
                                return false
                            }
                        }
                        return true
                    }).value()

                that.permanentId =
                    that.info.user && that.info.user.data
                        ? that.info.user.data.permanentId
                        : window.thrid

                hasInfo = !!that.info;

                (topWindow || window).$info = that.info;

                if(typeof parent != "undefined" && parent) {
                    parent.postMessage({type: 'info', info: that.info}, '*')
                }
                try {
                    storage.setItem('getinfo', JSON.stringify(that.info))
                }
                catch (e) {

                }
                return info
            }).catch(function (error) {
                console.error(error.stack)
            }).finally(function () {
                updateInfo()
            })
        })

    }

    function updateVariables() {
        storage.setItem('getinfo', JSON.stringify(that.info))
        setTimeout(function () {
            trigger('variables', that.variables)
        })
    }

    var updateInfo = _.debounce(function () {
        hasInfo = !!that.info
        if (hasInfo) {
            trigger('info', that.info)
            trigger('messages', that.info.messages)
            trigger('user', that.info.user)
//            trigger('locations', that.info.locations)
            invokeParams(infoList, that, that.info)
        }
    })

    var currentData = Q($.when())
    var codes = []
    var unlockdefer
    var sendCodes = _.throttle(function () {
        var defer = unlockdefer

        gtp('unlockmultiple/' + appName + '/' + that.thrid + '?cacheKill=' + Date.now(), {
            codes: codes
        }, "POST")
            .then(function (result) {
                processUnlockResults(result)
                defer.resolve(result)
                return result
            })
        codes = []
        unlockdefer = null
    }, 150, {
        leading: false,
        trailing: true,
        maxWait: 300
    })

    var startTime = Date.now();
    var heartBeatCount = 0;
    var heartBeatList = [1, 1, 1, 2, 2, 3, 3, 3, 5, 7, 10, 15, 20, 100, 1000, 5000]
    var heartBeatPos = 0
    //15 second heartbeat pulse to the server
    setInterval(function () {
        heartBeatCount++
        if (heartBeatCount >= heartBeatList[heartBeatPos]) {
            that.unlock('WEB.Heartbeat', Math.floor((Date.now() - startTime) / 1000))
            heartBeatCount = 0
            heartBeatPos = Math.min(heartBeatPos + 1, heartBeatList.length - 1)
        }
    }, 20000)
    var that = {
        api: api,
        gtp: gtp,
        canUpdateData: function (fn) {
            currentData = currentData.finally(function () {
                return Promise.resolve(fn())
            })
        },
        updateVariables: function () {
            that.variables = that.variables //update
        },
        getApiAddress: getApiAddress,
        updateThrid: function (thrid) {
            if(that.thrid == thrid && window.thrid == thrid) return
            window.thrid = thrid
            that.thrid = thrid
            storage.setItem('thrid', thrid)
            if ((topWindow || window).setId) {
                (topWindow || window).setId(thrid)
            }
            try {
                that.info.messages = []
                updateInfo()
                getLocations()
            } catch(e) {

            }
            trigger('thrid', thrid)
            if(typeof parent != "undefined" && parent) {
                parent.postMessage({
                    type: 'userinfo',
                    schemeId: schemeId,
                    thrid: thrid
                }, '*')
            }
        },
        read: function (message, extra) {
            var status
            message = resolveMessage(message)
            if (!message) return
            extra = extra || {}
            switch (status = message.ATTRIBUTES.status.toLowerCase()) {
                case 'read':
                case 'redeemed':
                    break
                default:
                    if (status == 'sent' || status == 'received') {
                        that.unlock('WM.ReadFirstTime', message.systemId)
                    }
                    message.ATTRIBUTES.status = 'read'
                    updateInfo()
                    return api('messageAction', _.merge(extra, {
                        action: 'read',
                        uid: that.thrid,
                        className: message.ATTRIBUTES.messageClassName,
                        msgId: message.ATTRIBUTES.id
                    })).then(function () {
                        message.ATTRIBUTES.status = 'read'
                        updateInfo()
                        trigger('read', message)
                    }).then(function () {
                        return that.unlock('WM.Read', message.systemId)
                    })

                    return Promise.resolve("ok")
            }
        },
        received: function (message, extra) {
            message = resolveMessage(message)
            extra = extra || {}
            switch (message.ATTRIBUTES.status.toLowerCase()) {
                case 'read':
                case 'redeemed':
                case 'received':
                    break
                default:
                    if ((schemeSettings).globals.receivedProcessing == 'no') {
                        message.ATTRIBUTES.status = 'received'
                    } else {
                    return api('messageAction', _.merge(extra, {
                        action: 'received',
                        uid: that.thrid,
                        className: message.ATTRIBUTES.messageClassName,
                        msgId: message.ATTRIBUTES.id
                    })).then(function () {
                        message.ATTRIBUTES.status = 'received'
                        trigger('received', message)
                    }).then(function () {
                        return that.unlock('WM.Received', message.systemId)
                    })
                    }

            }

            return Promise.resolve("ok")

        },
        redeemed: function (message, extra) {
            var status;
            message = resolveMessage(message)
            extra = extra || {}
            switch (status = message.ATTRIBUTES.status.toLowerCase()) {
                default:
                    message.ATTRIBUTES.status = 'redeemed'
                    updateInfo()
                    return api('messageAction', _.merge(extra, {
                        action: 'redeemed',
                        uid: that.thrid,
                        className: message.ATTRIBUTES.messageClassName,
                        msgId: message.ATTRIBUTES.id
                    })).then(function () {
                        message.ATTRIBUTES.status = 'redeemed'
                        getInfo()
                        trigger('redeemed', message)
                    }).then(function () {
                        return that.unlock('WM.Redeemed', message.systemId)
                            .then(function () {
                                if (status == 'read') {
                                    that.unlock('WM.RedeemedFirstTime', message.systemId)
                                }
                            })
                    })

                    break
            }

        },
        status: function (fn) {
            pushIfNeeded(statusList, fn)
            if (hasStatus) {
                fn(that.status)
            }
            return fn
        },
        messages: function (fn) {
            pushIfNeeded(infoList, fn)
            if (hasInfo) {
                fn(that.info)
            }
            return fn
        },
        newId: function (fn) {
            pushIfNeeded(idList, fn)
            if (hasId) {
                fn(that.thrid)
            }
            return fn
        },
        id: function (fn) {
            if (hasId) {
                fn(that.thrid)
                return
            }
            var f = function (id) {
                fn(id)
                that.remove(f)
            }
            pushIfNeeded(idList, f)
            return f
        },
        setDeviceId: function (newDeviceId) {
            if (!window.skipDevicePrefix && newDeviceId.indexOf('| |') == -1) {
                newDeviceId = schemeId + "| |" + (getParameterByName('application') ? getParameterByName('application') + ":" : "") + newDeviceId
            }
            that.deviceId = device = window.device =
                newDeviceId
            try {
                setItem('device-id', device)
            }
            catch (e) {

            }
            return register()
        },
        remove: function (fn) {
            remove(statusList, fn)
            remove(infoList, fn)
            remove(idList, fn)
        },
        referralCode: function (appAddress, source) {
            var parts = appAddress.split('?')
            var values = _.filter((parts.length > 1
                ? parts[1]
                : '').split('&'), function (d) {
                return d && !d.match(/(source|referrer)=/ig)
            })
            values.push('referrer=' + that.info.user.ATTRIBUTES.publicId)
            if(source) values.push("source=" + source)
            return parts[0] + '?' + values.join('&')
        },
        acknowledge: function (idOrMessage) {
            var id = idOrMessage.id || idOrMessage
            return gtp('ack/:thrid/:id', {
                thrid: Device.thrid,
                id: id
            })
        },
        getInfo: getInfo,
        getInfoVersion: function (version) {
            switch (version) {
                case 0:
                    that.getInfo = oldgetInfo
                    break
                default:
                    that.getInfo = getInfo
                    break
            }
        },
        gotInfo: function (fn) {
            if (that.info) {
                fn(that.info)
                return
            }
            var f = function (info) {
                fn(info)
                setTimeout(function () {
                    that.remove(f)
                })
            }
            pushIfNeeded(infoList, f)
            return f
        },
        unlock: function (code, packet) {
            return currentData.finally(function () {

                unlockdefer = unlockdefer ? unlockdefer : $.Deferred();
                var promise = unlockdefer.promise()
                var unlockable
                codes.push(unlockable = {
                    code: code,
                    packet: JSON.stringify(packet),
                    origin: sessionId
                })
                trigger('unlock', unlockable)
                sendCodes()
                return promise
            })
        },
        privateData: function (data) {
            return gtp('data/' + that.thrid + '/' + schemeId, {
                data: JSON.stringify(data),
                private: true
            })
        },
        data: function (data) {
            return currentData = gtp('data/' + that.thrid, {data: JSON.stringify(data)})
                .then(function (result) {
                    updateVariables()
                })
        },
        forget: function () {
            that.extraLogouts.forEach(function(fn) {
                fn()
            })
            if (typeof topWindow == "object" && topWindow.isRadicalApp) {
                that.api('registerDev', {mode: 'logout', publicId: that.info.user.ATTRIBUTES.publicId})
                storage.removeItem('getinfo')
                setTimeout(function () {
                    topWindow.location.reload()
                }, 2000)
            } else {
                var newId = guid() + ":" + schemeId
                if(typeof parent == "object") {
                    parent.postMessage({forget: true, duid: newId}, "*")
                }
                setItem('device-id', newId)
                storage.removeItem('getinfo')
                storage.removeItem('thrid')
                setTimeout(function () {
                    var loc = ((typeof topWindow == "object" ? topWindow : window).location.search||"").split('&').map(function(o) {
                        var parts = o.split('=')
                        if(!o) {
                            return o
                        }
                       
                        if(parts[0] && parts[0][0] == '?') {
                            parts[0] = parts[0].slice(1)
                        }
                        if(parts[0] == 'deviceId') {
                            parts[1] = encodeURIComponent(newId)
                        }
                        if(parts[0] == 'token') {
                            parts[0] = 'oldtoken'
                        }
                        return parts[0] + "=" + parts[1]
                    }).join('&')
                    var chosenWindow = typeof topWindow == "object" ? topWindow : window
                    var urlBefore = chosenWindow.location.href 
                    var urlAfter = chosenWindow.location.href.replace(/#.*/,'').split('?')[0] + "?" + loc

                    chosenWindow.location.href = urlAfter
                    if(urlBefore == urlAfter) {
                        chosenWindow.location.reload()
                    }
                }, 520)
            }
        },
        getMessage: function (id) {
            return lookup[id]
        },
        once: function (name, fn) {
            _(name.split(' '))
                .forEach(function (evt) {
                    var a = events[evt] = events[evt] || []

                    var remove = function remove() {
                        that.off(evt, remove)
                        fn()
                    }

                    a.push(remove)
                }).value()
        },
        on: function (name, fn, group) {
            _(name.split(' '))
                .forEach(function (evt) {
                    var a = events[evt] = events[evt] || []
                    a.push(fn)
                })
                var g = groups[group] = groups[group] || [];
            g.push({
                name: name,
                fn: fn
            })
        },
        off: function (name, fn) {
            (name || '').split(' ')
                .forEach(function (evt) {

                    if (typeof fn !== 'function') {
                        (groups[fn] || []).forEach(function (g) {
                            that.off(evt || g.name, g.fn)
                        })
                        groups[fn] = groups[fn].filter(function (g) {
                            return !(!evt || g.name == evt)
                        })
                    } else {
                        if (evt) {
                            var a = events[evt] = events[evt] || []
                            var idx = a.indexOf(fn)
                            if (idx != -1) {
                                a.splice(idx, 1)
                            }
                        }
                    }
                })
        },
        schemeId: schemeId,
        apiAddress: apiAddress,
        processUnlockResults: processUnlockResults,
        evaluateInContext: evaluateInContext,
        shouldRefreshInfo: shouldRefreshInfo,
        extraLogouts: []
    }

    if (typeof Device == "undefined") {
        var Device = that
    }

    var info = storage.getItem('getinfo')
    var thrid = storage.getItem('thrid')

    if (thrid) {
        setTimeout(function () {
            that.updateThrid(thrid)
            register()
        }.bind(this), 10)
    }

    if (info) {
        setTimeout(function () {
            that.info = JSON.parse(info)
            lookup = {}
            that.info.messages.forEach(function (m) {
                lookup[m.ATTRIBUTES.id] = m
            })
            that.permanentId =
                that.info.user && that.info.user.data
                    ? that.info.user.data.permanentId
                    : window.thrid

            hasInfo = !!that.info;

            (topWindow || window).$info = that.info;

            updateInfo()
        }, 10)
    }
    that.serveLocal = getParameterByName("local")
    that.deviceId = device
    that.gtpAddress = apiAddress + ':3040'
    that.isMobile = {
        Android: function () {
            return navigator.userAgent.match(/Android/i)
        },
        BlackBerry: function () {
            return navigator.userAgent.match(/BlackBerry/i)
        },
        iOS: function () {
            return navigator.userAgent.match(/iPhone|iPad|iPod/i)
        },
        Opera: function () {
            return navigator.userAgent.match(/Opera Mini/i)
        },
        Windows: function () {
            return navigator.userAgent.match(/IEMobile/i)
        },
        any: function () {
            return (Device.isMobile.Android() || Device.isMobile.BlackBerry() || Device.isMobile.iOS() || Device.isMobile.Opera() || Device.isMobile.Windows())
        }
    }

    function mergeReplaceArray(a, b) {
        if (_.isArray(a) || _.isArray(b)) return b
    }

    Object.defineProperties(that, {
        hidden: {
            get: function () {
                return isHidden()
            }
        },
        variables: {
            get: function () {
                return that.info && that.info.user
                    ? that.info.user.data.variables
                    : {}
            },
            set: function (value) {
                currentGetInfo.finally(function () {
                    _.merge(that.info.user.data.variables, value, mergeReplaceArray)
                    that.data(value).then(function (d) {
                        _.merge(that.info.user.data.variables, d, mergeReplaceArray)
                    })
                })
                _.merge(that.info.user.data.variables, value, mergeReplaceArray)

                updateVariables()
            }
        },
        private: {
            get: function () {
                {
                }
            },
            set: function (value) {
                currentGetInfo.finally(function () {
                    that.privateData(value);
                })
            }
        },
        hasInfo: {
            get: function () {
                return hasInfo
            }
        },
        innerWidth: {
            get: function () {
                return isiPad
                    ? 610
                    : window.innerWidth
            }
        },
        innerHeight: {
            get: function () {
                return isiPad
                    ? 510
                    : window.innerHeight
            }
        },
        allMessages: {
            get: function () {
                if (!that.info) {
                    return []
                }
                return that.info.messages
            }
        },
        evaluateInContext: evaluateInContext,
        shouldRefreshInfo: shouldRefreshInfo
    })

    function shouldRefreshInfo(data) {
        var lastRefresh

        if(!data) {
            return false
        }

        var thisRefresh = data.refresh || (data.response || {}).refresh


        if(typeof thisRefresh == 'number' && thisRefresh > 0) {
            lastRefresh = storage.getItem('lastRefresh')
            storage.setItem('lastRefresh', thisRefresh)
            return !lastRefresh || lastRefresh < thisRefresh
        } else {
            return thisRefresh
        }
    }

    if (globals) {
        window.picturePath = getApiAddress({
            port: 80,
            cdn: true,
            path: 'uploaded_pictures/'
        })
        window.serverLocations = {
            gtp: getApiAddress({port: 3040}) + "/",
            api: getApiAddress({port: 3030}) + "/",
            appCode: schemeId,
            secure: getApiAddress({port: 3040}) + "/",
            app: getApiAddress({port: 3020}),
            getInfo: getApiAddress({
                port: 3030,
                path: "api/getInfo"
            }),
            getSpendables: getApiAddress({
                port: 3030,
                path: "api/getSpendables"
            }),
            qrScan: getApiAddress({
                port: 3040,
                path: "qr"
            }),
            uploader: getApiAddress({
                port: 3040,
                path: "upload"
            }),
            unlockables: getApiAddress({
                port: 3040,
                path: "unlock/"
            }),
            unlockableCount: getApiAddress({
                port: 3040,
                path: "count/"
            }),
            unlockableMap: getApiAddress({
                port: 3030,
                path: "map/"
            })
        }

        window.rootPath = ''
        topWindow.unlock = window.unlock = function (code, packet) {
            return $.ajax({
                url: that.getApiAddress({port: 3040}) + "/unlock/" + schemeId + "/" + code + "/" + getId() + "?cacheKill=" + Date.now(),
                data : { packet : packet },
                type: 'POST',
                complete: [
                    makeProcessedByChangeDetector("gtp"),
                    makeRequestSizeReporter("gtp"),
                    makeRequestTimerReporter("gtp"),
                    makeRequestErrorReporter("gtp")
                ],
                dataType: 'json'
            })
        }
        window.currentGameInfo = {}

        window.showFrame = function (frm) {
            console.log(frm)
        }

        window.getId = function () {
            return Device.thrid
        }

        topWindow.unlockInfo = window.unlockInfo = function (unlockable) {
            var defer = $.Deferred();
            var serverInfo = {
                app: topWindow.appCode,
                address: topWindow.serverLocations.unlockableCount,
                id: topWindow.getId
                    ? topWindow.getId()
                    : undefined
            };
            if (!serverInfo.address) {
                setTimeout(function () {
                    topWindow.unlockInfo(unlockable);
                }, 500);
                return;
            }
            $.ajax({
                url: (serverInfo.address + unlockable),
                type: 'get',
                async: true,
                dataType: 'json'
            }).done(function (data) {
                defer.resolve(data);
            }).fail(function () {
                defer.resolve({count: 1000000});
            });
            return defer.promise();
        };

        topWindow.getUnlockInfo = function info(unlockables) {
            var defer = $.Deferred();
            unlockables = unlockables || '';
            if (!Array.isArray(unlockables)) {
                unlockables = unlockables.split(',');
            }
            var info = unlockables.filter(function (u) {
                return u;
            }).map(function (u) {
                return topWindow.unlockInfo(u);
            });
            if (info.length == 0) {
                defer.resolve();
            }
            else {
                $.when.apply($, info).done(function (result1) {
                    var results = [];
                    $.each(arguments, function (idx, arg) {
                        results.push(arg);
                    });
                    defer.resolve(results);
                }).fail(function () {
                    defer.reject();
                });
            }
            return defer.promise();
        }

        topWindow.exitCurrentWindow = function () {
            $(document).trigger(new $.Event('closeframe'))
        }

    }


    //Trigger a get info when the page is reshown
    that.on('shown', function () {
        that.getInfo()
    })

    if (typeof Radical == "object" && Radical.useOldStyleGetInfo) {
        that.getInfoVersion = 0
    }
    setTimeout(function () {
        that.unlock('WEB.started', sessionId)
    }, 1000)

    if (!thrid) {
        register()
    }

    return that
}

deviceFactory._depends = {
    symbol : "3r/device-api/device/deviceFactory",
    global : "deviceFactory",
    modules : [
        "jQuery",
        "_",
        "Q",
        "3r/storage",
        "3r/getApiAddress",
        "window",
        {
            symbol : "3r/schemeSettings/webapp",
            nullIfMissing : true
        }
    ]
}


if (typeof exports == "object") {
    exports.deviceFactory = deviceFactory
}

if (typeof window == "object" && window == this && this.ioc && typeof this.ioc.inject == "function") {
    window.deviceFactory = deviceFactory = this.ioc.inject(deviceFactory)
}
